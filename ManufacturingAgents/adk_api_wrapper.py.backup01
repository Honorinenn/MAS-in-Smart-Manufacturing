"""
ADK Integration Adapter
Bridges Agent Development Kit backend with React dashboard frontend
"""

# File: ManufacturingAgents/adk_api_wrapper.py

from fastapi import FastAPI, HTTPException, WebSocket, WebSocketDisconnect
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import Dict, List, Optional, Any
from datetime import datetime
import json
import os
import uvicorn
import httpx  # NEW: for Hugging Face calls
import requests

HF_API_TOKEN = os.getenv("HF_API_TOKEN")
HF_MODEL_URL = "https://api-inference.huggingface.co/models/mistralai/Mistral-7B-Instruct-v0.2"

def call_huggingface_model(prompt: str) -> str:
    if not HF_API_TOKEN:
        return "LLM backend unavailable (no HF token set). Falling back to ADK bridge."

    headers = {"Authorization": f"Bearer {HF_API_TOKEN}"}
    payload = {
        "inputs": prompt,
        "parameters": {"max_new_tokens": 200}
    }

    try:
        response = requests.post(HF_MODEL_URL, headers=headers, json=payload)
        data = response.json()

        if isinstance(data, list) and len(data) > 0 and "generated_text" in data[0]:
            return data[0]["generated_text"]
        return str(data)

    except Exception as e:
        return f"LLM backend error: {e}. Falling back to ADK bridge."


# ============================================================================ #
# CONFIG                                                                       #
# ============================================================================ #

HF_API_URL = (
    "https://api-inference.huggingface.co/models/"
    "mistralai/Mistral-7B-Instruct-v0.2"
)
HF_API_TOKEN = os.getenv("HF_API_TOKEN")  # set this in your env / Codespace

# Initialize FastAPI
app = FastAPI(
    title="ADK-React Bridge API",
    description="Bridge between Agent Development Kit and React Dashboard",
    version="1.0.0",
)

# Enable CORS (you can tighten this later)
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # or your specific 3000 URL
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# ============================================================================ #
# DATA MODELS                                                                  #
# ============================================================================ #


class MCPRequest(BaseModel):
    jsonrpc: str = "2.0"
    id: int
    method: str
    params: Dict[str, Any]


class MCPResponse(BaseModel):
    jsonrpc: str = "2.0"
    id: int
    result: Optional[Dict[str, Any]] = None
    error: Optional[Dict[str, Any]] = None


# ============================================================================ #
# ADK INTEGRATION                                                              #
# ============================================================================ #


class ADKBridge:
    """Bridge to communicate with ADK agents"""

    def __init__(self):
        self.agent_mapping = {
            "production": "production_agent",
            "inventory": "inventory_agent",
            "logistics": "logistics_agent",
            "maintenance": "maintenance_agent",
            "quality": "quality_control_agent",
            "supervisory": "supervisory_agent",
        }

        # Try to import your ADK agent runner
        self.adk_available = self._check_adk_available()

    def _check_adk_available(self) -> bool:
        """Check if ADK is available"""
        try:
            # Adjust this import to match your ADK setup
            # from agent import SupervisoryAgent
            return True
        except ImportError:
            print("⚠️  ADK not directly importable - using file-based communication")
            return False

    def get_agent_status(self, agent_id: str) -> Dict[str, Any]:
        """Get agent status from ADK"""

        # Method 1: Read from ADK state files (if available)
        status_file = f"supervisory_agent/data/{agent_id}_status.json"
        if os.path.exists(status_file):
            try:
                with open(status_file, "r") as f:
                    return json.load(f)
            except Exception as e:
                print(f"Error reading status file: {e}")

        # Method 2: Call ADK agent directly (if integrated)
        if self.adk_available:
            # Implement direct ADK call here
            pass

        # Method 3: Return simulated data for demo
        return self._get_simulated_status(agent_id)

    def _get_simulated_status(self, agent_id: str) -> Dict[str, Any]:
        """Generate simulated status based on agent type"""

        base_status = {
            "agent_id": agent_id,
            "timestamp": datetime.now().isoformat(),
            "source": "simulated",
        }

        if agent_id == "production":
            return {
                **base_status,
                "status": "operational",
                "efficiency": 87.5,
                "alerts": [
                    {"level": "warning", "message": "Line 2 below target efficiency"}
                ],
                "metrics": {
                    "production_rate": 120,
                    "active_lines": 3,
                    "total_lines": 4,
                },
            }

        elif agent_id == "inventory":
            return {
                **base_status,
                "status": "operational",
                "efficiency": 92.0,
                "alerts": [
                    {"level": "info", "message": "Inventory levels optimal"}
                ],
                "metrics": {
                    "total_items": 1245,
                    "low_stock_items": 0,
                    "reorder_pending": 0,
                },
            }

        elif agent_id == "logistics":
            return {
                **base_status,
                "status": "operational",
                "efficiency": 94.0,
                "alerts": [],
                "metrics": {
                    "active_shipments": 15,
                    "on_time_rate": 96.5,
                },
            }

        elif agent_id == "maintenance":
            return {
                **base_status,
                "status": "warning",
                "efficiency": 78.0,
                "alerts": [
                    {"level": "warning", "message": "Machine M003 needs maintenance"}
                ],
                "metrics": {
                    "machines_operational": 23,
                    "machines_maintenance": 2,
                },
            }

        elif agent_id == "quality":
            return {
                **base_status,
                "status": "operational",
                "efficiency": 96.0,
                "alerts": [],
                "metrics": {
                    "defect_rate": 2.1,
                    "inspections_today": 450,
                },
            }

        elif agent_id == "supervisory":
            return {
                **base_status,
                "status": "operational",
                "efficiency": 89.0,
                "alerts": [
                    {"level": "info", "message": "System monitoring active"}
                ],
                "metrics": {
                    "active_agents": 5,
                    "system_health": "good",
                },
            }

        return base_status

    def send_message_to_adk(self, agent_id: str, message: str) -> Dict[str, Any]:
        """Send message to ADK agent (placeholder)"""

        return {
            "agent_id": agent_id,
            "message_received": message,
            "response": f"Message forwarded to {agent_id} via ADK",
            "status": "acknowledged",
            "note": "For interactive chat, use ADK interface at your current UI",
        }


# Initialize bridge
adk_bridge = ADKBridge()

# ============================================================================ #
# HUGGING FACE LLM CALL                                                        #
# ============================================================================ #


async def call_hf_model(prompt: str) -> str:
    """Call Hugging Face Inference API server-side."""
    if not HF_API_TOKEN:
        raise RuntimeError("HF_API_TOKEN environment variable not set")

    headers = {
        "Authorization": f"Bearer {HF_API_TOKEN}",
        "Content-Type": "application/json",
    }

    payload = {
        "inputs": prompt,
        "parameters": {
            "max_new_tokens": 200,
            "temperature": 0.7,
            "top_p": 0.95,
            "do_sample": True,
            "return_full_text": False,
        },
    }

    async with httpx.AsyncClient(timeout=30.0) as client:
        resp = await client.post(HF_API_URL, headers=headers, json=payload)
        resp.raise_for_status()
        data = resp.json()

    # Extract generated text
    if isinstance(data, list) and data:
        text = data[0].get("generated_text", "")
    else:
        text = data.get("generated_text", "") if isinstance(data, dict) else ""

    text = (text or "No response generated").strip()
    return text


# ============================================================================ #
# API ENDPOINTS                                                                #
# ============================================================================ #


@app.get("/")
async def root():
    return {
        "name": "ADK-React Bridge API",
        "version": "1.0.0",
        "status": "operational",
        "backend": "Agent Development Kit",
        "endpoints": {
            "health": "/health",
            "mcp": "/api/mcp",
            "agents": "/api/agents",
            "docs": "/docs",
        },
    }


@app.get("/health")
async def health_check():
    return {
        "status": "healthy",
        "timestamp": datetime.now().isoformat(),
        "backend_type": "ADK",
        "agents": {
            agent_id: "online" for agent_id in adk_bridge.agent_mapping.keys()
        },
    }


@app.post("/api/mcp")
async def mcp_endpoint(request: MCPRequest):
    """MCP Protocol endpoint compatible with React frontend"""

    try:
        method = request.method
        params = request.params

        if method == "agent.status":
            agent_id = params.get("agent_id")
            if agent_id not in adk_bridge.agent_mapping:
                raise HTTPException(
                    status_code=404, detail=f"Agent '{agent_id}' not found"
                )

            result = adk_bridge.get_agent_status(agent_id)

        elif method == "system.status":
            result = {
                "system_status": "operational",
                "timestamp": datetime.now().isoformat(),
                "backend": "ADK",
                "agents": {
                    agent_id: adk_bridge.get_agent_status(agent_id)
                    for agent_id in adk_bridge.agent_mapping.keys()
                },
            }

        elif method == "agent.message":
            agent_id = params.get("agent_id")
            message = params.get("message")
            context = params.get("context") or {}

            if agent_id not in adk_bridge.agent_mapping:
                raise HTTPException(
                    status_code=404, detail=f"Agent '{agent_id}' not found"
                )

            # Get current agent status for richer prompt
            status = adk_bridge.get_agent_status(agent_id)

            # Basic prompt construction
            history = context.get("conversation") or ""
            prompt = (
                f"You are the '{agent_id}' agent in a smart factory.\n"
                f"Here is the latest status JSON:\n{json.dumps(status, indent=2)}\n\n"
                f"Conversation history (may be empty):\n{history}\n\n"
                f"User question:\n{message}\n\n"
                "Answer as the agent, referencing real values from the status when helpful."
            )

            # Try Hugging Face; fall back gracefully
            try:
                hf_reply = await call_hf_model(prompt)
                source = "huggingface"
            except Exception as e:
                print(f"HF error: {e}")
                base = adk_bridge.send_message_to_adk(agent_id, message)
                hf_reply = (
                    "LLM backend unavailable; falling back to ADK bridge.\n\n"
                    f"{base.get('response')}"
                )
                source = "fallback"

            result = {
                "agent_id": agent_id,
                "message_received": message,
                "response": hf_reply,
                "status": "ok",
                "source": source,
            }

        elif method == "agent.action":
            agent_id = params.get("agent_id")
            action = params.get("action")

            result = {
                "success": True,
                "message": f"Action '{action}' forwarded to ADK for agent '{agent_id}'",
                "note": "Execute actions through ADK interface for full functionality",
            }

        else:
            raise HTTPException(status_code=400, detail=f"Unknown method: {method}")

        return MCPResponse(jsonrpc="2.0", id=request.id, result=result)

    except HTTPException:
        raise
    except Exception as e:
        return MCPResponse(
            jsonrpc="2.0",
            id=request.id,
            error={"code": -32603, "message": str(e)},
        )


@app.get("/api/agents")
async def list_agents():
    return {
        "agents": [
            {
                "id": agent_id,
                "name": agent_name.replace("_", " ").title(),
                "status": adk_bridge.get_agent_status(agent_id),
            }
            for agent_id, agent_name in adk_bridge.agent_mapping.items()
        ]
    }


@app.get("/api/agents/{agent_id}")
async def get_agent(agent_id: str):
    if agent_id not in adk_bridge.agent_mapping:
        raise HTTPException(
            status_code=404, detail=f"Agent '{agent_id}' not found"
        )

    return adk_bridge.get_agent_status(agent_id)


@app.get("/api/adk/info")
async def adk_info():
    """Information about ADK integration"""
    return {
        "backend": "Agent Development Kit",
        "integration_status": "bridge_mode",
        "description": "This API provides read-only access to ADK agent status",
        "interactive_chat": "Use ADK interface for full agent interaction",
        "dashboard": "React dashboard provides monitoring and visualization",
        "agents_available": list(adk_bridge.agent_mapping.keys()),
    }


# ============================================================================ #
# OPTIONAL: SIMPLE WS FOR /ws/agent/{agent_id}                                 #
# ============================================================================ #


@app.websocket("/ws/agent/{agent_id}")
async def agent_ws(websocket: WebSocket, agent_id: str):
    await websocket.accept()
    try:
        while True:
            # For now just send periodic status updates; you can extend this.
            status = adk_bridge.get_agent_status(agent_id)
            await websocket.send_json(status)
            # Sleep a bit to avoid spamming (or wait for client messages)
            await websocket.receive_text()
    except WebSocketDisconnect:
        print(f"WebSocket disconnected for agent {agent_id}")


# ============================================================================ #
# RUN SERVER                                                                   #
# ============================================================================ #

if __name__ == "__main__":
    print("=" * 70)
    print(" ADK-React Bridge Server")
    print("=" * 70)
    print("API: http://localhost:8000")
    print("Docs: http://localhost:8000/docs")
    print("Backend: Agent Development Kit + Hugging Face LLM")
    print("Purpose: Bridge ADK agents to React dashboard")
    print("=" * 70)

    uvicorn.run(
        "adk_api_wrapper:app",
        host="0.0.0.0",
        port=8000,
        reload=True,
        log_level="info",
    )
